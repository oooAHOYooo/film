<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scene Viewer - Creatures in the Tall Grass Script</title>
    <link rel="stylesheet" href="script.css?v=20260108-5">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  </head>
  <body>
    <div class="gallery-container">
      <div class="nav no-print">
        <div class="nav-left">
          <a href="/pages/summer.html">← Summer Hub</a>
          <a href="index.html">← Back to Gallery</a>
          <a href="full_script.html">Full Script</a>
          <a href="/pages/summer/directors-notes/index.html">Director's Notes</a>
        </div>
        <button type="button" class="print-button"
          onclick="window.print()">Print</button>
      </div>

      <div class="screenplay-container" id="sceneContent">
        <p>Loading scene...</p>
      </div>
    </div>

    <script>
    function toRoman(num) {
      const map = [
        [1000, 'M'], [900, 'CM'], [500, 'D'], [400, 'CD'],
        [100, 'C'], [90, 'XC'], [50, 'L'], [40, 'XL'],
        [10, 'X'], [9, 'IX'], [5, 'V'], [4, 'IV'], [1, 'I']
      ];
      let n = num;
      let out = '';
      for (const [v, s] of map) {
        while (n >= v) { out += s; n -= v; }
      }
      return out;
    }

    // Get scene ID from URL
    const urlParams = new URLSearchParams(window.location.search);
    const sceneId = urlParams.get('id');

    if (!sceneId) {
      document.getElementById('sceneContent').innerHTML = 
        '<p>No scene ID provided. <a href="index.html">Return to gallery</a></p>';
    } else {
      // Load manifest to find scene file
      async function loadScene() {
        try {
          const manifestResponse = await fetch('manifest.json');
          const scenes = await manifestResponse.json();
          
          const sceneIndex = scenes.findIndex(s => s.id === sceneId);
          const scene = scenes[sceneIndex];
          
          if (!scene) {
            document.getElementById('sceneContent').innerHTML = 
              `<p>Scene "${sceneId}" not found. <a href="index.html">Return to gallery</a></p>`;
            return;
          }

          const sceneNumber = sceneIndex + 1;
          const actLabel = scene.act ? `ACT ${toRoman(scene.act)} — ${(scene.actTitle || '').trim()}`.trim() : '';

          // Load the scene markdown file
          const sceneResponse = await fetch(`scenes/${scene.file}`);
          const markdown = await sceneResponse.text();
          
          // Convert markdown to HTML
          marked.setOptions({ breaks: true });
          const html = marked.parse(markdown);
          
          // Display scene
          const container = document.getElementById('sceneContent');
          container.innerHTML = `
            <div class="full-script-header">
              <div class="full-script-title">Scene ${sceneNumber}: ${scene.title}</div>
              <div class="full-script-meta">${actLabel ? `${actLabel} | ` : ''}Scene ID: ${scene.id} | File: ${scene.file}</div>
            </div>
            <div class="screenplay-content">
              ${html}
            </div>
          `;
          
          // Format screenplay elements
          formatScreenplay(container);
          
          // Update page title
          document.title = `${scene.title} - Creatures in the Tall Grass Script`;
        } catch (error) {
          console.error('Error loading scene:', error);
          document.getElementById('sceneContent').innerHTML = 
            `<p>Error loading scene: ${error.message}. <a href="index.html">Return to gallery</a></p>`;
        }
      }

      loadScene();
    }

    // True if line looks like action (character intro or narrative), not dialogue
    function looksLikeActionIntro(text) {
      if (!text || text.length < 15) return false;
      if (/^\(.+\)$/.test(text)) return false;
      if (/^(INT\.|EXT\.|FADE|CUT|DISSOLVE)/i.test(text)) return false;
      // "Name, age/description, action" e.g. "Janice, Mid 50s, puts her hand on Dominic's shoulder."
      if (/^[A-Z][a-z]+,\s*(?:Mid\s*\d+s|\d+s|[A-Za-z\s]+),/.test(text) && /[a-z]/.test(text)) return true;
      if (/^[A-Z][a-z]+,\s*(?:Mid\s*\d+s|\d+s)\s*[,.]/.test(text)) return true;
      return false;
    }

    // Format screenplay elements after markdown is rendered
    function formatScreenplay(container) {
      const content = container.querySelector('.screenplay-content');
      if (!content) return;

      normalizeParagraphBreaks(content);

      const paragraphs = content.querySelectorAll('p');
      let inDialogueBlock = false;
      
      paragraphs.forEach((p, index) => {
        const text = p.textContent.trim();
        const nextP = paragraphs[index + 1];
        const prevP = paragraphs[index - 1];
        
        // Skip if already formatted (but allow normalizeParagraphBreaks output)
        if (!text) return;
        if (p.classList.length > 0 && !p.classList.contains('line-split')) return;
        
        // Scene headings (INT. or EXT. at start of line)
        if (/^(INT\.|EXT\.)/i.test(text)) {
          p.className = 'scene-heading';
          p.textContent = text.toUpperCase();
          inDialogueBlock = false;
          return;
        }
        
        // Transitions (right-aligned, uppercase)
        if (/^(FADE IN|FADE OUT|CUT TO|DISSOLVE TO|SMASH CUT|MATCH CUT)/i.test(text)) {
          p.className = 'transition';
          p.textContent = text.toUpperCase();
          inDialogueBlock = false;
          return;
        }

        // Action break: (action) on its own line — ends dialogue block, next line is action; line is hidden
        if (/^\(action\)$/i.test(text)) {
          p.className = 'action-break';
          p.textContent = '';
          inDialogueBlock = false;
          return;
        }
        
        // Parentheticals (text in parentheses, italic) - check before character names
        if (/^\(.+\)$/.test(text)) {
          p.className = 'parenthetical';
          inDialogueBlock = true;
          return;
        }

        // Action lines that introduce a character or describe action (e.g. "Janice, Mid 50s, puts her hand...")
        // Never treat these as dialogue so they don't get wrapped with the previous speaker
        if (looksLikeActionIntro(text)) {
          p.className = 'action-line';
          inDialogueBlock = false;
          return;
        }
        
        // Character names (all caps, typically short, not scene headings)
        // Must be all caps, reasonable length, and followed by dialogue or parenthetical
        const isAllCaps = /^[A-Z][A-Z\s\.'-]+$/.test(text) && text === text.toUpperCase();
        const isReasonableLength = text.length > 2 && text.length < 35;
        const isNotSceneHeading = !/^(INT\.|EXT\.|FADE|CUT|DISSOLVE)/i.test(text);
        
        if (isAllCaps && isReasonableLength && isNotSceneHeading) {
          // Check if next element suggests this is a character name
          const nextText = nextP ? nextP.textContent.trim() : '';
          const looksLikeDialogue = nextText && (
            /^\(.+\)$/.test(nextText) || // Next is parenthetical
            (!/^(INT\.|EXT\.|FADE|CUT|DISSOLVE)/i.test(nextText) && 
             !/^[A-Z][A-Z\s\.'-]+$/.test(nextText)) // Next is not all caps
          );
          
          if (looksLikeDialogue || !prevP || prevP.classList.contains('action-line') || prevP.classList.contains('scene-heading')) {
            p.className = 'character-name';
            inDialogueBlock = true;
            return;
          }
        }
        
        // Dialogue (follows character name / parenthetical / dialogue)
        const looksLikeNewBlock = /^(INT\.|EXT\.|FADE IN|FADE OUT|CUT TO|DISSOLVE TO|SMASH CUT|MATCH CUT)/i.test(text);
        const looksLikeCharacter = isAllCaps && isReasonableLength && isNotSceneHeading;
        if (!looksLikeNewBlock && !looksLikeActionIntro(text) && inDialogueBlock && prevP && (prevP.classList.contains('character-name') || prevP.classList.contains('parenthetical') || prevP.classList.contains('dialogue'))) {
          p.className = 'dialogue';
          inDialogueBlock = true;
          return;
        }
        
        // If we're in a dialogue block but this doesn't match, end the block
        if (looksLikeCharacter || looksLikeNewBlock) {
          inDialogueBlock = false;
        }
        
        // Default: action line
        p.className = 'action-line';
        inDialogueBlock = false;
      });

      // Add markers for last line in dialogue / parenthetical blocks (spacing)
      const ps = content.querySelectorAll('p');
      ps.forEach((p, i) => {
        if (!p.classList.contains('dialogue') && !p.classList.contains('parenthetical')) return;
        const next = ps[i + 1];
        if (!next || (!next.classList.contains('dialogue') && !next.classList.contains('parenthetical'))) {
          if (p.classList.contains('dialogue')) p.classList.add('dialogue-last');
          if (p.classList.contains('parenthetical')) p.classList.add('parenthetical-last');
        }
      });
    }

    // Split <p> blocks that contain <br> into separate <p>s per line.
    // This lets screenplay formatting work even if the markdown uses single newlines.
    function normalizeParagraphBreaks(content) {
      const paragraphs = Array.from(content.querySelectorAll('p'));
      paragraphs.forEach((p) => {
        if (!p.querySelector('br')) return;
        const parts = p.innerHTML
          .split(/<br\s*\/?\s*>/i)
          .map((s) => s.replace(/&nbsp;/g, ' ').trim())
          .filter(Boolean);
        if (parts.length <= 1) return;

        const frag = document.createDocumentFragment();
        parts.forEach((html) => {
          const np = document.createElement('p');
          np.innerHTML = html;
          frag.appendChild(np);
        });
        p.replaceWith(frag);
      });
    }
  </script>
  </body>
</html>
